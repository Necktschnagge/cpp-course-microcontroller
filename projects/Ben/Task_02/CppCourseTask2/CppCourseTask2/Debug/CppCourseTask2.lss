
CppCourseTask2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
<<<<<<< HEAD
  0 .data         00000000  00800100  00800100  00000166  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000112  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  00000166  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000198  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000030  00000000  00000000  000001d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000007f8  00000000  00000000  00000208  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000006c9  00000000  00000000  00000a00  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000002cf  00000000  00000000  000010c9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000044  00000000  00000000  00001398  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000441  00000000  00000000  000013dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000001c4  00000000  00000000  0000181d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000020  00000000  00000000  000019e1  2**0
=======
  0 .data         00000000  00800100  00800100  000000ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000009a  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  000000ee  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000120  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000028  00000000  00000000  00000160  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000006b3  00000000  00000000  00000188  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000062f  00000000  00000000  0000083b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000000eb  00000000  00000000  00000e6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000034  00000000  00000000  00000f58  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000003a3  00000000  00000000  00000f8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000018  00000000  00000000  0000132f  2**0
>>>>>>> b8c7d71d446c649e5327db8900b3d82dfc602513
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   8:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  10:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  14:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  18:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  1c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  20:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  24:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  28:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  2c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  30:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  34:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  38:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  3c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  40:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  44:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  48:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  4c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  50:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  54:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  58:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  5c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  60:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  64:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61
<<<<<<< HEAD
  74:	0e 94 58 00 	call	0xb0	; 0xb0 <main>
  78:	0c 94 87 00 	jmp	0x10e	; 0x10e <_exit>
=======
  74:	0e 94 43 00 	call	0x86	; 0x86 <main>
  78:	0c 94 4b 00 	jmp	0x96	; 0x96 <_exit>
>>>>>>> b8c7d71d446c649e5327db8900b3d82dfc602513

0000007c <__bad_interrupt>:
  7c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000080 <_Z9GPIO_Initv>:
		}		
	}
}

void GPIO_Init(){
	DDRD |= 0b00000001;
  80:	50 9a       	sbi	0x0a, 0	; 10
	PORTD |= 0b00000010;
  82:	59 9a       	sbi	0x0b, 1	; 11
  84:	08 95       	ret

00000086 <_Z9LED_Blinkv>:
}

void LED_Blink(){
	PORTD |= 0b00000001;
  86:	58 9a       	sbi	0x0b, 0	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

<<<<<<< HEAD
	__builtin_avr_delay_cycles(__ticks_dc);
  88:	2f ef       	ldi	r18, 0xFF	; 255
  8a:	83 ec       	ldi	r24, 0xC3	; 195
  8c:	99 e0       	ldi	r25, 0x09	; 9
  8e:	21 50       	subi	r18, 0x01	; 1
  90:	80 40       	sbci	r24, 0x00	; 0
  92:	90 40       	sbci	r25, 0x00	; 0
  94:	e1 f7       	brne	.-8      	; 0x8e <_Z9LED_Blinkv+0x8>
  96:	00 c0       	rjmp	.+0      	; 0x98 <_Z9LED_Blinkv+0x12>
  98:	00 00       	nop
	_delay_ms(200);
	PORTD &= 0b11111110;
  9a:	58 98       	cbi	0x0b, 0	; 11
  9c:	2f ef       	ldi	r18, 0xFF	; 255
  9e:	83 ec       	ldi	r24, 0xC3	; 195
  a0:	99 e0       	ldi	r25, 0x09	; 9
  a2:	21 50       	subi	r18, 0x01	; 1
  a4:	80 40       	sbci	r24, 0x00	; 0
  a6:	90 40       	sbci	r25, 0x00	; 0
  a8:	e1 f7       	brne	.-8      	; 0xa2 <_Z9LED_Blinkv+0x1c>
  aa:	00 c0       	rjmp	.+0      	; 0xac <_Z9LED_Blinkv+0x26>
  ac:	00 00       	nop
  ae:	08 95       	ret

000000b0 <main>:
int main(void)
{
	uint16_t	counter {0};	
	uint16_t	blinker {0};
	uint32_t	timeout {32000000};
	GPIO_Init();
  b0:	0e 94 40 00 	call	0x80	; 0x80 <_Z9GPIO_Initv>

int main(void)
{
	uint16_t	counter {0};	
	uint16_t	blinker {0};
	uint32_t	timeout {32000000};
  b4:	80 e0       	ldi	r24, 0x00	; 0
  b6:	98 e4       	ldi	r25, 0x48	; 72
  b8:	a8 ee       	ldi	r26, 0xE8	; 232
  ba:	b1 e0       	ldi	r27, 0x01	; 1
void LED_Blink();

int main(void)
{
	uint16_t	counter {0};	
	uint16_t	blinker {0};
  bc:	00 e0       	ldi	r16, 0x00	; 0
  be:	10 e0       	ldi	r17, 0x00	; 0
void GPIO_Init();
void LED_Blink();

int main(void)
{
	uint16_t	counter {0};	
  c0:	c0 e0       	ldi	r28, 0x00	; 0
  c2:	d0 e0       	ldi	r29, 0x00	; 0
  c4:	04 c0       	rjmp	.+8      	; 0xce <main+0x1e>
  c6:	84 e0       	ldi	r24, 0x04	; 4
  c8:	90 e0       	ldi	r25, 0x00	; 0
  ca:	a0 e0       	ldi	r26, 0x00	; 0
  cc:	b0 e0       	ldi	r27, 0x00	; 0
	uint32_t	timeout {32000000};
=======
int main(void)
{
	uint16_t counter {0};
	
>>>>>>> b8c7d71d446c649e5327db8900b3d82dfc602513
	GPIO_Init();
	
	/* Replace with your application code */
	while (1){
<<<<<<< HEAD
		if(!(PIND & 0b10)){						// wenn taster gedrückt
  ce:	49 99       	sbic	0x09, 1	; 9
  d0:	14 c0       	rjmp	.+40     	; 0xfa <main+0x4a>
			while(!(PIND & 0b10)){
  d2:	49 99       	sbic	0x09, 1	; 9
  d4:	10 c0       	rjmp	.+32     	; 0xf6 <main+0x46>
  d6:	2f ef       	ldi	r18, 0xFF	; 255
  d8:	39 e6       	ldi	r19, 0x69	; 105
  da:	48 e1       	ldi	r20, 0x18	; 24
  dc:	21 50       	subi	r18, 0x01	; 1
  de:	30 40       	sbci	r19, 0x00	; 0
  e0:	40 40       	sbci	r20, 0x00	; 0
  e2:	e1 f7       	brne	.-8      	; 0xdc <main+0x2c>
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <main+0x36>
  e6:	00 00       	nop
				_delay_ms(500);
				timeout--;
  e8:	01 97       	sbiw	r24, 0x01	; 1
  ea:	a1 09       	sbc	r26, r1
  ec:	b1 09       	sbc	r27, r1
				if(timeout < 1){
  ee:	89 f7       	brne	.-30     	; 0xd2 <main+0x22>
					counter = 0;
  f0:	c0 e0       	ldi	r28, 0x00	; 0
  f2:	d0 e0       	ldi	r29, 0x00	; 0
  f4:	ee cf       	rjmp	.-36     	; 0xd2 <main+0x22>
				}
			}
			counter++;
  f6:	21 96       	adiw	r28, 0x01	; 1
			blinker = counter;
  f8:	8e 01       	movw	r16, r28
		}
		if (blinker > 0){
  fa:	01 15       	cp	r16, r1
  fc:	11 05       	cpc	r17, r1
  fe:	29 f0       	breq	.+10     	; 0x10a <main+0x5a>
			LED_Blink();
 100:	0e 94 43 00 	call	0x86	; 0x86 <_Z9LED_Blinkv>
			blinker--;
 104:	01 50       	subi	r16, 0x01	; 1
 106:	11 09       	sbc	r17, r1
 108:	de cf       	rjmp	.-68     	; 0xc6 <main+0x16>
			timeout = 4;
		} else {
			PORTD &= 0b11111110;
 10a:	58 98       	cbi	0x0b, 0	; 11
 10c:	dc cf       	rjmp	.-72     	; 0xc6 <main+0x16>

0000010e <_exit>:
 10e:	f8 94       	cli

00000110 <__stop_program>:
 110:	ff cf       	rjmp	.-2      	; 0x110 <__stop_program>
=======
		if( PIND & 0b10 ) { // wenn taster nicht gedrückt
  8a:	49 9b       	sbis	0x09, 1	; 9
  8c:	02 c0       	rjmp	.+4      	; 0x92 <main+0xc>
			PORTD &= 0b11111110;
  8e:	58 98       	cbi	0x0b, 0	; 11
  90:	fc cf       	rjmp	.-8      	; 0x8a <main+0x4>
		} else {
			PORTD |= 0b00000001;	
  92:	58 9a       	sbi	0x0b, 0	; 11
  94:	fa cf       	rjmp	.-12     	; 0x8a <main+0x4>

00000096 <_exit>:
  96:	f8 94       	cli

00000098 <__stop_program>:
  98:	ff cf       	rjmp	.-2      	; 0x98 <__stop_program>
>>>>>>> b8c7d71d446c649e5327db8900b3d82dfc602513
